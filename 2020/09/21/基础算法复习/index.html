<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>基础算法复习 - Garlicisnotmyfavor</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Garlicisnotmyfavor"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Garlicisnotmyfavor"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="算法方面忘得很多了，也比较长时间没有使用C&amp;#x2F;C++，这学期事情不是很多，有时间可以看看。"><meta property="og:type" content="blog"><meta property="og:title" content="基础算法复习"><meta property="og:url" content="http://garlicisnotmyfavor.xyz/2020/09/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"><meta property="og:site_name" content="Garlicisnotmyfavor"><meta property="og:description" content="算法方面忘得很多了，也比较长时间没有使用C&amp;#x2F;C++，这学期事情不是很多，有时间可以看看。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.macw.com/pic/202001/17153932_c7bfa941cf.jpeg"><meta property="article:published_time" content="2020-09-21T02:53:21.000Z"><meta property="article:modified_time" content="2020-12-12T02:40:57.127Z"><meta property="article:author" content="Garlic"><meta property="article:tag" content="算法"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://pic.macw.com/pic/202001/17153932_c7bfa941cf.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://garlicisnotmyfavor.xyz/2020/09/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},"headline":"Garlicisnotmyfavor","image":[],"datePublished":"2020-09-21T02:53:21.000Z","dateModified":"2020-12-12T02:40:57.127Z","author":{"@type":"Person","name":"Garlic"},"description":"算法方面忘得很多了，也比较长时间没有使用C&#x2F;C++，这学期事情不是很多，有时间可以看看。"}</script><link rel="canonical" href="http://garlicisnotmyfavor.xyz/2020/09/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">garlicisnotmyfavor</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://pic.macw.com/pic/202001/17153932_c7bfa941cf.jpeg" alt="基础算法复习"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-21T02:53:21.000Z" title="2020-09-21T02:53:21.000Z">2020-09-21</time>发表</span><span class="level-item"><time dateTime="2020-12-12T02:40:57.127Z" title="2020-12-12T02:40:57.127Z">2020-12-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="level-item">24 分钟读完 (大约3540个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">基础算法复习</h1><div class="content"><p>算法方面忘得很多了，也比较长时间没有使用C/C++，这学期事情不是很多，有时间可以看看。</p>
<a id="more"></a>

<h4 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>判断输入是否结束：<code>while (scanf(&quot;%d, &amp;h&quot;) != EOF)</code> 在事先不清楚有多少数据的情况下通过 <code>scanf</code> 的返回值，即成功赋值的个数来达到判断的功能</p>
<p>日期题目闰年的判断语句：<code>(year%4 == 0 &amp;&amp; year%100 != 0)||(year%400 == 0)</code></p>
<h4 id="排序和查找"><a href="#排序和查找" class="headerlink" title="排序和查找"></a>排序和查找</h4><h5 id="sort函数："><a href="#sort函数：" class="headerlink" title="sort函数："></a>sort函数：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">sort(first, last, comp)</span><br></pre></td></tr></table></figure>

<p>默认为升序排列，若要更灵活地实现排序，则要自己编写comp函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(Student x, Student y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.score == y.score)&#123;</span><br><span class="line">		<span class="keyword">return</span> x.number &lt; y.number</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x.score &lt; y.score</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设计排序算法时的一个tip：当比较函数的返回值是true时，表示的是比较函数的第一个参数将会排在第二个参数前面。</p>
<p>对于结构体或类的自定义排序，还可以用sort函数按照题面要求定义不同的排序规则。</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">	whhile(left &lt; right)&#123;</span><br><span class="line">		<span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[middle] &lt; target)&#123;</span><br><span class="line">			left = middle+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; arr[middle])&#123;</span><br><span class="line">			right = middle<span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数据很大时，为防止溢出，可以用 <code>int middle = left+(right-left)/2</code>替代 <code>int middle = (left+right)/2</code></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="string的使用"><a href="#string的使用" class="headerlink" title="string的使用"></a>string的使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">n = str.size()</span><br><span class="line"><span class="comment">//迭代器访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it = str.begin(); it != str.end(); ++it)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在任意位置插入元素</span></span><br><span class="line">str.insert(str.size(), <span class="string">&quot;end world&quot;</span>);</span><br><span class="line"><span class="comment">//在任意位置删除元素</span></span><br><span class="line">str.erase(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//将字符串清空</span></span><br><span class="line">str.clear();</span><br><span class="line"><span class="comment">//可以使用加号拼接字符串</span></span><br><span class="line">str1 = str+str2;</span><br><span class="line"><span class="comment">//判断字符串关系</span></span><br><span class="line">str1 &lt;= str2;</span><br><span class="line"><span class="comment">//find查找特定字符串，若找到对应的字符/字符串就返回对应下标；找不到则返回string::npos</span></span><br><span class="line"><span class="keyword">int</span> found = str.find(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">//返回字符串子串的函数substr()</span></span><br><span class="line"><span class="built_in">string</span> str2 = str1.substr(<span class="number">3</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>当输入是一行字符串时，使用：<code>while(getline(cin, str))&#123;&#125;</code></p>
<p>初始化数组：<code>memset(number, 0, sizeof(number));</code></p>
<h5 id="字符串匹配-KMP"><a href="#字符串匹配-KMP" class="headerlink" title="字符串匹配(KMP)"></a>字符串匹配(KMP)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nextTable[MAXM];</span><br><span class="line"><span class="keyword">int</span> pattern[MAXM];</span><br><span class="line"><span class="keyword">int</span> text[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextTable</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    nextTable[j] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = nextTable[j];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">-1</span> || pattern[j] == pattern[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            nextTable[j] = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = nextTable[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    GetNextTable(m);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || text[i] == pattern[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextTable[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == m)&#123;</span><br><span class="line">        <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> caseNumber;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;caseNumber);</span><br><span class="line">    <span class="keyword">while</span>(caseNumber--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, n, m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;text[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pattern[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, KMP(n, m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="向量vector"><a href="#向量vector" class="headerlink" title="向量vector"></a>向量vector</h5><ol>
<li>头文件和声明：<code>#include &lt;vector&gt;</code> <code>vector&lt;typename&gt; name</code></li>
<li>vector的状态：当前是否为空的 <code>empty()</code>, 返回当前向量元素个数 <code>size()</code></li>
<li>vector尾部元素的添加或删除。<code>push_back()</code> <code>pop_back()</code></li>
<li>元素的访问：下标访问，从0到size()-1；通过迭代器访问，类似指针</li>
<li>元素操作：<code>insert()</code> <code>erase()</code> <code>clear()</code> </li>
<li>迭代器操作：首元素 <code>begin()</code>  尾元素 <code>end()</code> </li>
<li>使用场合：在数据量不确定的情况下完成数据的处理，还可以实现图论中的邻接表</li>
</ol>
<h5 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h5><ol>
<li>定义：<code>#include &lt;queue&gt;</code> <code>queue&lt;typename&gt; name</code></li>
<li>判断是否为空：<code>empty()</code>  元素个数：<code>size()</code></li>
<li>queue元素的添加或删除：<code>push()</code> <code>pop()</code></li>
<li>queue元素的访问：<code>front()</code> <code>back()</code></li>
</ol>
<h5 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h5><ol>
<li>定义：<code>#include &lt;stack&gt;</code> <code>stack&lt;typename&gt; name</code></li>
<li>判断是否为空：<code>empty()</code>  元素个数：<code>size()</code></li>
<li>stack元素的添加或删除：<code>push()</code> <code>pop()</code></li>
<li>stack元素的访问：<code>top()</code> </li>
</ol>
<p>一个字符串小技巧：<code>string answer(str.size(), &#39; &#39;);</code></p>
<p>典型题：括号匹配，简单计算器</p>
<h4 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h4><h5 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h5><p>基本代码如下，一般情况下会遇到只能以字符串形式储存，需要设计字符串计算的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; binary;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            binary.push_back(n % <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = binary.size()<span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, binary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h5><p>最大公约数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GCD(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b) != EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, GCD(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最小公倍数用的公式就是：a*b/GCD(a, b)</p>
<p>质数</p>
<p>判断是否为素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bound = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i &lt; bound; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>素数筛法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        isPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPrime[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        prime.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;MAXN; j+=i)&#123;</span><br><span class="line">            isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分解质因数：在素数筛法的基础上完成</p>
<p>快速幂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FastExponentiation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            answer *= a;</span><br><span class="line">            answer %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">        a *= a;</span><br><span class="line">        a %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>矩阵与矩阵快速幂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    Matrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c): row(r), col(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Multipy</span><span class="params">(Matrix x, Matrix y)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">answer</span><span class="params">(x.row, y.col)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; answer.row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;answer.col; j++)&#123;</span><br><span class="line">            answer.matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; j &lt; answer.col; k++)&#123;</span><br><span class="line">                answer.matrix[i][j] += x.matrix[i][k]*y.matrix[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrix</span><span class="params">(Matrix x)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">FastExponentiation</span><span class="params">(Matrix x, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">answer</span><span class="params">(x.row, x.col)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;answer.row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;answer.col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) answer.matrix[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> answer.matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            answer = Multipy(answer, x);</span><br><span class="line">        &#125;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">        x = Multipy(x, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心思想和前面的非矩阵快速幂一致</p>
<p>高精度整数（给一个模板，但只适合正整数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct BigInteger&#123;</span><br><span class="line">    int digit[MAXN];</span><br><span class="line">    int length;</span><br><span class="line">    BigInteger();</span><br><span class="line">    BigInteger(int x);</span><br><span class="line">    BigInteger(string str);</span><br><span class="line">    BigInteger(const BigInteger&amp; b);</span><br><span class="line">    BigInteger operator&#x3D;(int x);</span><br><span class="line">    BigInteger operator&#x3D;(string str);</span><br><span class="line">    BigInteger operator&#x3D;(const BigInteger&amp; b);</span><br><span class="line">    bool operator&lt;&#x3D;(const BigInteger&amp; b);</span><br><span class="line">    bool operator&#x3D;&#x3D;(const BigInteger&amp; b);</span><br><span class="line">    BigInteger operator+(const BigInteger&amp; b);</span><br><span class="line">    BigInteger operator-(const BigInteger&amp; b);</span><br><span class="line">    BigInteger operator*(const BigInteger&amp; b);</span><br><span class="line">    BigInteger operator&#x2F;(const BigInteger&amp; b);</span><br><span class="line">    BigInteger operator%(const BigInteger&amp; b);</span><br><span class="line">    friend istream&amp; operator&gt;&gt;(istream&amp; in, BigInteger&amp; x);</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const BigInteger&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中每一个部分都有相应板块的代码，具体见书P107（太长了，最好理解了敲来背）</p>
<h4 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h4><p> 贪心策略一般用在优化问题上，其核心思想是选择当前状态下的最优解，即不以整体最优进行考虑，而只考虑当下这一步。但在某些问题中，局部最优能收敛到全局最优，使用贪心就很有效果。这类最优问题的特点是具备无后效性，即某个状态以前的过程不会影响以后的状态，而只与当前状态有关。</p>
<h5 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h5><p>指当有多个不同的区间存在，且这些区间有可能相互重叠的时候，如何选择才能从众多区间中，选取最多的两两互不相交的区间。</p>
<p>列题：搭桥问题</p>
<p>有n个岛屿，每个岛屿都可以用直线上不相交的线段表示，岛屿的坐标为$[l_i, r_i]$，对于所有$1 \leq i \leq n-1$都有$r_i &lt; l_{i+1}$为了能让两个临近的岛屿相连接，需要在其之间架一座桥。长度为a的桥可以架在第i和第i+1号岛屿之间，如果它们的坐标为x和y，则有$l_i \leq x \leq r_i$，$l_{i+1} \leq y \leq r_{i +1}$和$y-x=a$。</p>
<p>我们可以使用m座桥，每座桥最多可以使用一次。请确定他可用的桥梁是否能够连接每对相邻的岛屿。</p>
<p>题解：</p>
<p>一共n个岛屿的话，可以得到n-1个需要架的桥的区间（相邻的才架），对于每个区间设定[minimum, maxmum]，对区间按照minimum排序，对给的桥按照length排序。最后在所有能满足的区间中，选择maxmum最小的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Island</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bridge</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minimum;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxmum;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> index; <span class="comment">//区间编号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (Interval x) <span class="keyword">const</span>&#123; <span class="comment">//操作符的重载</span></span><br><span class="line">        <span class="keyword">return</span> maxmum &gt; x.maxmum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntervalCompare</span><span class="params">(Interval x, Interval y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.minimum == y.minimum)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.maxmum &lt; y.maxmum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.minimum &lt; y.minimum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BridgeCompare</span><span class="params">(Bridge x, Bridge y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.length &lt; y.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Island island[MAXN];</span><br><span class="line">Bridge bridge[MAXN];</span><br><span class="line">Interval interval[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> answer[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Interval&gt; myQueue; <span class="comment">//优先队列的性质</span></span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">//当前区间的下标</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">//搭建桥的数目</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(myQueue.top().maxmum &lt; bridge[i].length &amp;&amp; !myQueue.empty())&#123;</span><br><span class="line">            myQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(position &lt; n<span class="number">-1</span> &amp;&amp; </span><br><span class="line">              (interval[position].minimum &lt;= bridge[i].length) &amp;&amp;</span><br><span class="line">              (interval[position].maxmum &gt;= bridge[i].length))&#123;</span><br><span class="line">            myQueue.push(interval[position]);</span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!myQueue.empty())&#123;</span><br><span class="line">            Interval current = myQueue.top();</span><br><span class="line">            myQueue.pop();</span><br><span class="line">            answer[current.index] = bridge[i].index;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number == (n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(island, <span class="number">0</span>, <span class="keyword">sizeof</span>(island));</span><br><span class="line">        <span class="built_in">memset</span>(bridge, <span class="number">0</span>, <span class="keyword">sizeof</span>(bridge));</span><br><span class="line">        <span class="built_in">memset</span>(interval, <span class="number">0</span>, <span class="keyword">sizeof</span>(interval));</span><br><span class="line">        <span class="built_in">memset</span>(answer, <span class="number">0</span>, <span class="keyword">sizeof</span>(answer));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;island[i].left, &amp;island[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">//输入桥的信息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算区间，排序，选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码涉及到优先队列，他的用法和概念后面说。</p>
<h4 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h4><p>构成递归需要具备两个条件：</p>
<ol>
<li>子问题必须与原始问题相同，且规模更小，尝试列出等式</li>
<li>不能无限制地调用本身，必须有一个递归出口</li>
</ol>
<p>分治法，“分而治之”，即把复杂的问题分成两个或更多个子问题，子问题间相互独立且与原问题相同或相似，持续分直到最后的子问题可以简单直接求解。分治法中也和递归有结合，它们是相互依存的。</p>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><h5 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h5><ul>
<li>状态。需要确定所求解问题中的状态，通过状态的扩展，遍历所有的状态，从中寻找需要的答案</li>
<li>状态的扩展方式。</li>
<li>有效状态。有一些状态不需要再次扩展可以直接舍弃</li>
<li>队列。为了使得状态能够先扩展，使用队列，将得到的状态依次放入队尾，每次取对头元素进行扩展</li>
<li>标记。区分有效和无效的状态（比如下面代码要区分已经访问过了还是没有访问）</li>
<li>有效状态数。估计是否在时间范围内能完成整个搜索</li>
<li>最优。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//储存位置和时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Status</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, t;</span><br><span class="line">    Status(<span class="keyword">int</span> n, <span class="keyword">int</span> t): n(n), t(t)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Status&gt; myQueue;</span><br><span class="line">    myQueue.push(Status(n, <span class="number">0</span>));</span><br><span class="line">    visit[n] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!myQueue.empty())&#123;</span><br><span class="line">        Status current = myQueue.front();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        <span class="keyword">if</span>(current.n == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> current.t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="function">Status <span class="title">next</span><span class="params">(current.n, current.t+<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                next.n += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                next.n -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                next.n *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next.n &lt; <span class="number">0</span> || next.n &gt;= MAXN || visit[next.n])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            myQueue.push(next);</span><br><span class="line">            visit[next.n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, BFS(n, k));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p>通常使用递归函数，一般不能来求最优解，而是使用来判断有无解，是存在性问题。注意不能递归层数太深，可能会出现“爆栈”的问题</p>
<h4 id="数据结构二"><a href="#数据结构二" class="headerlink" title="数据结构二"></a>数据结构二</h4><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><h6 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h6><p>先根节点-左-右</p>
<h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p>左-根-右</p>
<h6 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h6><p>左-右-根</p>
<h6 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h6><p>需要设置队列来装</p>
<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p>二叉排序树的特点：</p>
<ol>
<li>左子树非空的话，左子树上所有结点关键字的值小于根结点关键字的值</li>
<li>右子树非空的话，右子树上所有结点关键字的值大于根结点关键字的值</li>
<li>左右子树本身也是一棵二叉排序树</li>
</ol>
<h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>能够将数据按事先规定的优先级进行动态组织的数据结构称为优先队列，访问元素时，只能访问当前队列中优先级最高的元素。</p>
<ol>
<li>在头文件queue中，定义为<code>priority_queue&lt;typename&gt; name</code></li>
<li>元素个数size()，是否为空empty()，push()，pop()，访问top()</li>
<li>默认为大顶堆，即优先级高的先输出。要改为小顶堆：<code>priority_queue&lt;typename, vector&lt;typename&gt;, greater&lt;typename&gt;&gt; name</code></li>
</ol>
<p>哈夫曼树：<br>带权路径长度和最小的二叉树。求解时每次找最小的两个结点组合起来。</p>
<h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>一般的搜索方式，无论是向量还是树，结构中元素存放位置与元素的关键字之间并不存在确定的关系，因此在查找时需要对关键字进行比较，最好也就是$O(log_n)$，但是使用散列表直接对关键字进行访问的话，可以在$O(1)$下完成。</p>
<p>先介绍标准库中的map，map是将关键字和映射值形成一一映射绑定存储的容器，底层是用红黑树实现的，内部依然有序，所以查找效率为$O(log_n)$。标准库中还有一个无序映射unordered_map，底层是散列表，期望查找效率为$O(1)$。在数据量不大时，map可以完成几乎所有工作了，如果实在需要使用unordered_map，直接改一下名称就好，用法基本一样。</p>
<ol>
<li>定义：在 <code>&lt;map&gt;</code>中，需要 <code>map&lt;typename1, typename2&gt; name</code></li>
<li>状态有两个，empty()和size()</li>
<li>添加和删除：insert()  erase()</li>
<li>访问用[key]或者at()或者迭代器</li>
<li>查找特定元素find()，找到时返回的是该元素的迭代器，没找到就返回迭代器end()</li>
<li>映射清空的操作clear()</li>
<li>map迭代器操作：begin()  end()</li>
</ol>
<h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><p>图的结构可以用邻接矩阵或邻接表表示，分类上可以分为有向/无向图，是否带权。</p>
<h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>并查集用于处理一些不交集的合并和查询问题。有以下两个功能：</p>
<ul>
<li>判断任意两个元素是否属于同一个集合；</li>
<li>按照要求合并不同的集合；</li>
</ul>
<p>首先将集合在逻辑上表示为树结构，每个结点都指向其父节点，而树中的元素无顺序之分，在同一棵树上的就是一个集合中的。并查集有两个操作，查找和合并</p>
<p>查找：确定元素属于哪个集合。不断向上查找，直到找到他的根结点，之后根据根节点是否相同来判断两个元素是否属于一个集合。</p>
<p>合并：将一棵树作为另一颗树的子树，从而使得两棵树变为一棵更大的树。</p>
<p>为了避免不好的树的形态（最差的就是退化为单链表），需要对合并做一定的约束和优化，具体下来就是路径压缩。在查找到某个结点的根结点时，将其与根节点之间的所有结点都直接指向根结点。且还有个小技巧，就是在合并时，总是将高度较低的树，作为高度较高的树的子树进行合并。</p>
<p>应用：在图论中，用来判断是否为连通图，或用来求图的连通分量。</p>
<p>连通图的定义：在一个无向图G中，若顶点u到顶点v有路径相连，则两点是相连的。若图中任意两点都是连通的，则为连通图。而G中的一个极大连通子图为G的一个连通分量。连通图只有自己为唯一的连通分量</p>
<h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>如果存在一个连通子图，包含原图中所有顶点和部分边，且这个子图不存在回路，则 为原图的一棵生成树。在带权无向连通图中，所有生成树中边权的和最小的那一颗被称为该无向图的最小生成树。常见算法：Kruskal和Prim</p>
<h5 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h5><p>Dijkstra算法</p>
<h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p>针对的有向无环图。按照方向排一个序。</p>
<h5 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h5><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>动态规划通常用于求解最优解的问题，与分治法类似，基本思想都是将待求问题分解成若干个子问题，先求解子问题，然后从这些子问题中得到原问题的解。但与分治法不同的是，适合用于动态规划求解的问题，经分解得到的子问题往往不是相互独立的。若用分治法来解这类问题，则分解得到的子问题太多，有些子问题会被重复计算很多次。而动态规划的做法是将已解决子问题的答案保存下来，在需要子问题答案的时候便可直接获得，而不需要重复计算，这样可以避免大量的重复计算，提高效率。</p>
<h5 id="递推求解"><a href="#递推求解" class="headerlink" title="递推求解"></a>递推求解</h5><h5 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h5><h5 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h5><h5 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h5><h5 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h5></div><div class="article-licensing box"><div class="licensing-title"><p>基础算法复习</p><p><a href="http://garlicisnotmyfavor.xyz/2020/09/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/">http://garlicisnotmyfavor.xyz/2020/09/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Garlic</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-09-21</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-12-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/22/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%9A%84%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">基于对称密码的加密流量异常检测系统</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/21/%E7%BC%BA%E9%99%B7owner/"><span class="level-item">缺陷owner</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://garlicisnotmyfavor.xyz/2020/09/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/';
            this.page.identifier = '2020/09/21/基础算法复习/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'garlicisnotmyfavor' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Garlic"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Garlic</p><p class="is-size-6 is-block">一生温暖纯良 不舍爱与自由</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/garlicisnotmyfavor" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/garlicisnotmyfavor"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#暴力求解"><span class="level-left"><span class="level-item">1</span><span class="level-item">暴力求解</span></span></a></li><li><a class="level is-mobile" href="#排序和查找"><span class="level-left"><span class="level-item">2</span><span class="level-item">排序和查找</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sort函数："><span class="level-left"><span class="level-item">2.1</span><span class="level-item">sort函数：</span></span></a></li><li><a class="level is-mobile" href="#二分查找"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">二分查找</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字符串"><span class="level-left"><span class="level-item">3</span><span class="level-item">字符串</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#string的使用"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">string的使用</span></span></a></li><li><a class="level is-mobile" href="#字符串匹配-KMP"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">字符串匹配(KMP)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据结构"><span class="level-left"><span class="level-item">4</span><span class="level-item">数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#向量vector"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">向量vector</span></span></a></li><li><a class="level is-mobile" href="#队列Queue"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">队列Queue</span></span></a></li><li><a class="level is-mobile" href="#栈stack"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">栈stack</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数学问题"><span class="level-left"><span class="level-item">5</span><span class="level-item">数学问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#进制转换"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">进制转换</span></span></a></li><li><a class="level is-mobile" href="#最大公约数与最小公倍数"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">最大公约数与最小公倍数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#贪心策略"><span class="level-left"><span class="level-item">6</span><span class="level-item">贪心策略</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#区间贪心"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">区间贪心</span></span></a></li></ul></li><li><a class="level is-mobile" href="#递归与分治"><span class="level-left"><span class="level-item">7</span><span class="level-item">递归与分治</span></span></a></li><li><a class="level is-mobile" href="#搜索"><span class="level-left"><span class="level-item">8</span><span class="level-item">搜索</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#宽度优先搜索"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">宽度优先搜索</span></span></a></li><li><a class="level is-mobile" href="#深度优先搜索"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">深度优先搜索</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据结构二"><span class="level-left"><span class="level-item">9</span><span class="level-item">数据结构二</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#二叉树"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">二叉树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#前序遍历"><span class="level-left"><span class="level-item">9.1.1</span><span class="level-item">前序遍历</span></span></a></li><li><a class="level is-mobile" href="#中序遍历"><span class="level-left"><span class="level-item">9.1.2</span><span class="level-item">中序遍历</span></span></a></li><li><a class="level is-mobile" href="#后序遍历"><span class="level-left"><span class="level-item">9.1.3</span><span class="level-item">后序遍历</span></span></a></li><li><a class="level is-mobile" href="#层次遍历"><span class="level-left"><span class="level-item">9.1.4</span><span class="level-item">层次遍历</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉排序树"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">二叉排序树</span></span></a></li><li><a class="level is-mobile" href="#优先队列"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">优先队列</span></span></a></li><li><a class="level is-mobile" href="#散列表"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">散列表</span></span></a></li></ul></li><li><a class="level is-mobile" href="#图论"><span class="level-left"><span class="level-item">10</span><span class="level-item">图论</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#并查集"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">并查集</span></span></a></li><li><a class="level is-mobile" href="#最小生成树"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">最小生成树</span></span></a></li><li><a class="level is-mobile" href="#最短路径"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">最短路径</span></span></a></li><li><a class="level is-mobile" href="#拓扑排序"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">拓扑排序</span></span></a></li><li><a class="level is-mobile" href="#关键路径"><span class="level-left"><span class="level-item">10.5</span><span class="level-item">关键路径</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态规划"><span class="level-left"><span class="level-item">11</span><span class="level-item">动态规划</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#递推求解"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">递推求解</span></span></a></li><li><a class="level is-mobile" href="#最大连续子序列和"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">最大连续子序列和</span></span></a></li><li><a class="level is-mobile" href="#最长递增子序列"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">最长递增子序列</span></span></a></li><li><a class="level is-mobile" href="#最长公共子序列"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">最长公共子序列</span></span></a></li><li><a class="level is-mobile" href="#背包问题"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">背包问题</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">garlicisnotmyfavor</a><p class="is-size-7"><span>&copy; 2020 Garlic</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>